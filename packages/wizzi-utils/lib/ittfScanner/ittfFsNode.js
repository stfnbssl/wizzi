/*
    artifact generator: C:\My\wizzi\stfnbssl\wizzi.lastsafe.plugins\packages\wizzi.plugin.js\lib\artifacts\js\module\gen\main.js
    package: wizzi-js@
    primary source IttfDocument: C:\My\wizzi\stfnbssl\wizzi\packages\wizzi-utils\.wizzi\lib\ittfScanner\ittfFsNode.js.ittf
    utc time: Fri, 16 Aug 2024 08:42:14 GMT
*/
'use strict';
// generated by wizzi.plugin.js.artifacts.js.module.gen.main
function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var verify = require('@wizzi/helpers').verify;
var path = require('path');
var async = require('async');
var vfile = require('../fSystem/vfile');
var verify = require('../helpers/verify');
var IttfDocumentGraph = require('../ittfGraph/ittfDocumentGraph');
var ittfHtmlPrettifier = require('../pretty/ittfHtmlPrettifier');
var mTreeHtmlPrettifier = require('../pretty/mTreeHtmlPrettifier');
/**
    
     File or directory in a folder tree structure of ITTF Documents.
     Is the result of a scanners.folderScanner(folderPath, option) execution.
     Can export its content to a wizzi.utils.ittfDocumentGraph, calling the method 'toIttf'.
     The root node collects mixed or included ittf fragments that are
     outside (up) of root.ittfBasePath.
    
     { IttfFsNode
     { parent
     ref IttfFsNode || null
     string path
     string basename
     string dirname
     boolean isDirectory
     [ parts
     string schema
     # schema of ittf document file
     boolean isFragment
     # ittf document file is inside a t-folder
     boolean isTFolder
     # folder basename is t
     boolean isInsideTFolder
     # folder is descendant of a t-folder
     [ folders
     [ documents
     # if method 'setSourcePaths' is called
     string ittfBasePath
     string jsCodeBasePath
     # if method 'analize' has been called
     boolean isTest
     boolean isExample
     boolean isUtil
     boolean isTest
     boolean isJobFolder
     boolean isPackageRoot
    
*/
var IttfFsNode = (function () {
    function IttfFsNode(nodePath, parent, options) {
        _classCallCheck(this, IttfFsNode);
        this.parent = parent;
        if (parent) {
            this.path = nodePath;
            this.fullPath = unixifyPath(path.join(parent.fullPath, nodePath));
            this.relPath = this.fullPath.substr(parent.root().fullPath.length + 1);
        }
        else {
            this.path = this.fullPath = unixifyPath(nodePath);
            this.isRoot = true;
            this.relPath = '';
        }
        this.isDirectory = options.isDirectory;
        this.file = options.file;
        this.isFragment = false;
        this.isExternal = false;
        this.parts = this.fullPath.split('/');
        this.segments = this.parts.slice(0, this.parts.length -1);
        this.basename = this.parts[this.parts.length -1];
        this.dirname = this.segments.join('/');
        // loog 'ittfScanner.IttfFsNode.ctor.nodePath', nodePath, 'this.basename', this.basename, 'this.path', this.path, 'this.fullPath', this.fullPath
        // loog 'ittfScanner.IttfFsNode.ctor.options', options
        if (!options.isDirectory) {
            this.schema = detectSchema(this.basename);
            this.isFragment = isTFragment(this.parts);
        }
        else {
            this.isTFolder = this.basename.toLowerCase() === 't';
            this.isInsideTFolder = isTFragment(this.parts) && (!this.isTFolder);
        }
        this.folders = [];
        this.documents = [];
        this.info = {
            schemas: {}, 
            lib: {
                documents: []
             }, 
            test: {
                documents: []
             }, 
            example: {
                documents: []
             }, 
            util: {
                documents: []
             }
         };
        
        // In the root set mixed or included ITTF Fragments that are outside (up) of root.ittfBasePath
        if (this.parent == null) {
            this.ittfBasePath = unixifyPath(nodePath);
            this.jsCodeBasePath = null;
            this.externalFragments = [];
            this.externalIttfFsNodes = [];
        }
        this.analized = false;
    }
    IttfFsNode.prototype.root = function() {
        return this.parent == null ? this : this.parent.root();
    }
    IttfFsNode.prototype.setInfo = function(callback) {
        if (typeof(callback) !== 'function') {
            throw new Error(
                error('InvalidArgument', 'setInfo', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        var r = this.root();
        console.log('called setInfo', this.basename, r === this, __filename);
        if (r === this) {
            this.setIds();
            var that = this;
            this.analize(function(err, notUsed) {
                if (err) {
                    return callback(err);
                }
                // loog 'analized', that.basename
                that.__setInfo(r, callback)
            })
        }
        else {
            this.__setInfo(r, callback)
        }
    }
    IttfFsNode.prototype.__setInfo = function(r, callback) {
        console.log('called __setInfo', this.basename, this.isDirectory, this.isFragment, !this.isDirectory && !this.isFragment, __filename);
        if (!this.isDirectory && !this.isFragment) {
            var schema = r.info.schemas[this.schema];
            
            // loog 'created schema', schema, r.info.schemas
            if (!schema) {
                schema = {
                    name: this.schema, 
                    documents: []
                 };
                r.info.schemas[this.schema] = schema;
            }
            // loog 'found', schema, r.info.schemas
            else {
            }
            schema.documents.push(this);
            if (this.isTest) {
                r.info.test.documents.push(this);
            }
            else if (this.isExample) {
                r.info.example.documents.push(this);
            }
            else if (this.isUtil) {
                r.info.util.documents.push(this);
            }
            else {
                r.info.lib.documents.push(this);
            }
        }
        var that = this;
        if (this.isDirectory) {
            function doLoopFolders(ndx) {
                var folder = that.folders[ndx];
                if (!folder) {
                    function doLoopDocuments(ndxDoc) {
                        var document = that.documents[ndxDoc];
                        if (!document) {
                            return callback(null, r);
                        }
                        console.log('document setted', document.basename, __filename);
                        document.setInfo(function(err, notUsed) {
                            if (err) {
                                return callback(err);
                            }
                            doLoopDocuments(ndxDoc + 1)
                        })
                    }
                    return doLoopDocuments(0);
                }
                folder.setInfo(function(err, notUsed) {
                    if (err) {
                        return callback(err);
                    }
                    doLoopFolders(ndx + 1)
                })
            }
            return doLoopFolders(0);
        }
        else {
            return callback(null, r);
        }
    }
    IttfFsNode.prototype.addDocument = function(relPath, options) {
        //
        // FIXME options.basePath seems not used
        //
        var r = this.root();
        var tobeAddedFullPath = unixifyPath(path.join(this.fullPath, relPath));
        relPath = unixifyPath(relPath);
        // loog 'addDocument relPath', relPath, 'to this.fullPath', this.fullPath
        var parts = tobeAddedFullPath.split('/');
        // loog 'addDocument parts.length', parts.length, 'to this.parts.length', this.parts.length
        
        // loog 'addDocument parts.length <= this.parts.length return null'
        if (parts.length <= this.parts.length) {
            return null;
        }
        
        // loog 'addDocument this.match(parts) == false return null'
        if (this.match(parts) == false) {
            return null;
        }
        
        // loog 'addDocument could be a document try match'
        
        // loog '+++ addDocument added document', parts[parts.length-1], 'to', this.path
        if (parts.length == this.parts.length + 1) {
            var dnode = new IttfFsNode(parts[parts.length-1], this, {
                isDirectory: false, 
                file: r.file
             });
            this.documents.push(dnode);
            return dnode;
        }
        // loog 'addDocument try subfolder', subfolder, 'subRelPath', subRelPath
        // loog 'addDocument created subfolder', subfolderPath
        // loog '+++ addDocument created subfolder', subfolder, 'in folder', this.path
        else {
            var relPathParts = relPath.split('/');
            var subfolder = relPathParts[0];
            var subRelPath = relPathParts.slice(1).join('/');
            var added;
            var i, i_items=this.folders, i_len=this.folders.length, f;
            for (i=0; i<i_len; i++) {
                f = this.folders[i];
                if (f.path === subfolder) {
                    added = f.addDocument(subRelPath, options);
                    ;
                    return added;
                }
            }
            var fnode = new IttfFsNode(subfolder, this, {
                isDirectory: true, 
                file: r.file
             });
            this.folders.push(fnode);
            added = fnode.addDocument(subRelPath, options);
            ;
            return added;
        }
    }
    IttfFsNode.prototype.addExternalDocument = function(fullPath) {
        var r = this.root();
        if (r !== this) {
            throw new Error('wizzi-utils.ittfFsNode.addExternalDocument must be called on root node only.');
        }
        var relPath = path.relative(this.ittfBasePath, fullPath);
        // loog 'addExternalDocument.relPath', relPath, 'fullPath', fullPath
        var dnode = this.searchDocument(relPath);
        
        // loog 'addExternalDocument.relPath already exists', relPath,
        if (dnode) {
            return dnode;
        }
        // loog 'addExternalDocument.relPath added', relPath
        else {
            dnode = new IttfFsNode(relPath, this, {
                isDirectory: false, 
                file: r.file
             });
            ;
            dnode.isExternal = true;
            this.documents.push(dnode);
            return dnode;
        }
    }
    IttfFsNode.prototype.match = function(parts) {
        if (parts.length < this.parts.length) {
            return false;
        }
        var i, i_items=this.parts, i_len=this.parts.length, part;
        for (i=0; i<i_len; i++) {
            part = this.parts[i];
            if (part !== this.parts[i]) {
                return false;
            }
        }
        return true;
    }
    IttfFsNode.prototype.setIds = function(r) {
        if (typeof r === 'undefined') {
            r = this.root();
        }
        if (this === r) {
            this.id = 'root-parent-folder';
        }
        else {
            this.id = r.__getNewId(this.isDirectory);
        }
        if (this.isDirectory) {
            var i, i_items=this.folders, i_len=this.folders.length, folder;
            for (i=0; i<i_len; i++) {
                folder = this.folders[i];
                folder.setIds();
            }
            var i, i_items=this.documents, i_len=this.documents.length, d;
            for (i=0; i<i_len; i++) {
                d = this.documents[i];
                d.setIds();
            }
        }
    }
    // returns
    // fnnn for folders
    // dnnn for documents
    IttfFsNode.prototype.__getNewId = function(isDirectory) {
        if (isDirectory) {
            if (typeof(this.f_idcount) === 'undefined') {
                this.f_idcount = 0;
            }
            return 'f_' + (++this.f_idcount);
        }
        else {
            if (typeof(this.d_idcount) === 'undefined') {
                this.d_idcount = 0;
            }
            return 'd_' + (++this.d_idcount);
        }
    }
    // called for example by scanners.scanFolder on the root node
    IttfFsNode.prototype.setSourcePaths = function(options) {
        if (verify.isNotEmpty(options.ittfBasePath)) {
            this.ittfBasePath = unixifyPath(options.ittfBasePath);
        }
        if (verify.isNotEmpty(options.jsCodeBasePath)) {
            this.jsCodeBasePath = unixifyPath(options.jsCodeBasePath);
        }
        // loog 'wizzi-utils.ittfFsNode.setSourcePaths - ittfBasePath, jsCodeBasePath : ', options.ittfBasePath, options.jsCodeBasePath
    }
    //
    // FIXME this is NOT OK
    // ittfHtmlPrettifier uses IttfDocumentGraph to analize the ittf document and to recognize fragments.
    // That is a scanning operation that must be executed before prettifying.
    //
    IttfFsNode.prototype.getPrettyAnalizedIttfSource = function() {
        var r = this.root();
        // loog 'wizzi-utils.ittfFsNode.getPrettyAnalizedIttfSource', r.ittfBasePath, this.parts.join('/')
        if (verify.isNotEmpty(r.ittfBasePath)) {
            return ittfHtmlPrettifier(path.join(r.ittfBasePath, this.parts.join('/')), {
                    ittfFsNode: this, 
                    ittfBasePath: (r.ittfBasePath)
                 });
        }
        else {
            return {
                    __is_error: true
                 };
        }
    }
    IttfFsNode.prototype.getJsCode = function() {
        var r = this.root();
        // cut '.ittf' from basename
        var name = this.basename.substr(0, this.basename.length - 5);
        if (this.schema == 'js') {
            return file.read(path.join(r.jsCodeBasePath, this.parts.slice(2, this.parts.length -1).join('/'), name));
        }
        else {
            return null;
        }
    }
    IttfFsNode.prototype.analize = function(callback) {
        if (typeof(callback) !== 'function') {
            throw new Error(
                error('InvalidArgument', 'analize', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        // loog 'wizzi-utils.ittfFsNode.analize.relPath', this.isDirectory, this.basename
        var r = this.root();
        if (r === this) {
            this.setIds();
        }
        if (this.relPath.indexOf('/tests/') > -1) {
            this.isTest = true;
        }
        if (this.relPath.indexOf('/examples/') > -1) {
            this.isExample = true;
        }
        if (this.relPath.indexOf('/util/') > -1 || this.relPath.indexOf('/utils/') > -1) {
            this.isUtil = true;
        }
        if (this.containsDocument('generate.wzjob.ittf') && this.containsFolder('ittf')) {
            if (this.isTest || this.isExample) {
                this.isJobFolder = true;
            }
            else {
                this.isPackageRoot = true;
            }
        }
        this.analized = true;
        var that = this;
        if (this.isDirectory) {
            function doLoopFolders(ndx) {
                var folder = that.folders[ndx];
                if (!folder) {
                    function doLoopDocuments(ndxDoc) {
                        var document = that.documents[ndxDoc];
                        if (!document) {
                            return callback(null);
                        }
                        document.analize(function(err, notUsed) {
                            if (err) {
                                return callback(err);
                            }
                            doLoopDocuments(ndxDoc + 1)
                        })
                    }
                    return doLoopDocuments(0);
                }
                folder.analize(function(err, notUsed) {
                    if (err) {
                        return callback(err);
                    }
                    doLoopFolders(ndx + 1)
                })
            }
            return doLoopFolders(0);
        }
        // loog 'ittfFsNode.analize this.parts.join("/")', this.parts.join('/')
        else {
            var that = this;
            IttfDocumentGraph.createFrom(this.parts.join('/'), {
                file: r.file
             }, function(err, ittfDocumentGraph) {
                if (err) {
                    return callback(err);
                }
                // loog 'wizzi-utils.ittfFsNode.analize.created ittfDocumentGraph'
                var ctx = {
                    fragments: {}, 
                    externalFragments: {}, 
                    ittfReferences: {}, 
                    ittfFsNode: that, 
                    ittfBasePath: r.ittfBasePath
                 };
                ittfDocumentGraph.analize(ctx, function(err, notUsed) {
                    if (err) {
                        return callback(err);
                    }
                    // loog 'wizzi-utils.ittfFsNode.analize.ctx.fragments from ittfDocumentGraph', ctx.fragments
                    that.ittfDocumentGraph = ittfDocumentGraph;
                    that.fragments = ctx.fragments;
                    // TODO review this
                    var max_repeat = 3;
                    function repeat(count) {
                        // loog 'wizzi-utils.ittfFsNode.analize.repeat count', count
                        if (Object.keys(ctx.externalFragments).length < 1 || count > max_repeat) {
                            return callback(null);
                        }
                        async.map(Object.keys(ctx.externalFragments), function(k, callback) {
                            // loog 'wizzi-utils.ittfFsNode.analize.repeat externalFragment', ctx.externalFragments[k].uri
                            var dnode = r.addExternalDocument(ctx.externalFragments[k].uri);
                            // loog 'external dnode', dnode
                            dnode.setIds();
                            dnode.analize(function(err, notUsed) {
                                if (err) {
                                    return callback(err);
                                }
                                ctx.fragments = {};
                                ctx.externalFragments = {};
                                ittfDocumentGraph.analize(ctx, function(err, notUsed) {
                                    if (err) {
                                        return callback(err);
                                    }
                                    that.fragments = ctx.fragments;
                                    // loog 'wizzi-utils.ittfFsNode.analize.externalFragments', ctx.externalFragments
                                    return callback(null);
                                })
                            })
                        }, function(err, result) {
                            if (err) {
                                return callback(err);
                            }
                            repeat(count + 1);
                        })
                    }
                    repeat(1);
                })
            })
        }
    }
    IttfFsNode.prototype.containsDocument = function(testBaseName) {
        var i, i_items=this.documents, i_len=this.documents.length, d;
        for (i=0; i<i_len; i++) {
            d = this.documents[i];
            if (d.basename === testBaseName) {
                return true;
            }
        }
    }
    IttfFsNode.prototype.containsFolder = function(testBaseName) {
        var i, i_items=this.folders, i_len=this.folders.length, f;
        for (i=0; i<i_len; i++) {
            f = this.folders[i];
            if (f.basename === testBaseName) {
                return true;
            }
        }
    }
    IttfFsNode.prototype.searchDocument = function(dFullPath) {
        var searchPath = unixifyPath(dFullPath);
        var r = this.root();
        return r.__searchDocument(searchPath);
    }
    IttfFsNode.prototype.__searchDocument = function(dFullPath) {
        // loog '__searchDocument, this.fullPath, dFullPath', this.fullPath, dFullPath
        
        // loog '__searchDocument, found'
        if (this.fullPath === dFullPath) {
            return this;
        }
        else {
            var ret = null;
            var i, i_items=this.documents, i_len=this.documents.length, d;
            for (i=0; i<i_len; i++) {
                d = this.documents[i];
                ret = d.__searchDocument(dFullPath);
                if (ret != null) {
                    return ret;
                }
            }
            var i, i_items=this.folders, i_len=this.folders.length, f;
            for (i=0; i<i_len; i++) {
                f = this.folders[i];
                ret = f.__searchDocument(dFullPath);
                if (ret != null) {
                    return ret;
                }
            }
        }
        return null;
    }
    IttfFsNode.prototype.toIttfRoot = function(ittfDocumentGraph) {
        var kempty = "";
        var kschema = "schema";
        var kfolder = "folder";
        var klib = "lib";
        var kutil = "util";
        var ktest = "test";
        var kexample = "example";
        var r = this;
        var comment = ittfDocumentGraph.add('#', '`fs-base-uri` is the dirname of `package-base-uri`' + kempty);
        comment = ittfDocumentGraph.add('#', '`rel-dirname(s)` and `rel-uri(s)` of `f` and `d` nodes are relative to `fs-base-uri`' + kempty)
        ;
        var fsBaseUri = ittfDocumentGraph.add('fs-base-uri', r.ittfBasePath);
        var packageBaseUri = ittfDocumentGraph.add('package-base-uri', r.ittfBasePath + '/' + this.basename);
        var gitBaseUri = ittfDocumentGraph.add('git-base-uri', r.jsCodeBasePath);
        var inf = ittfDocumentGraph.add('fs-info', kempty);
        var dg, t, any;
        for (var k in r.info.schemas) {
            dg = inf.add('d-group', k)
            ;
            t = dg.add('type', kschema)
            ;
            // foreach d in r.info.schemas[k].documents
            // addset(any, dg, d, d.path)
        }
        
        // foreach d in r.info.lib.documents
        
        // addset(any, dg, d, d.path)
        if (r.info.lib.documents.length > 0) {
            dg = inf.add('d-group', klib)
            ;
            t = dg.add('type', kfolder)
            ;
        }
        
        // foreach d in r.info.util.documents
        
        // addset(any, dg, d, d.path)
        if (r.info.util.documents.length > 0) {
            dg = inf.add('d-group', kutil)
            ;
            t = dg.add('type', kfolder)
            ;
        }
        
        // foreach d in r.info.test.documents
        
        // addset(any, dg, d, d.path)
        if (r.info.test.documents.length > 0) {
            dg = inf.add('d-group', ktest)
            ;
            t = dg.add('type', kfolder)
            ;
        }
        
        // foreach d in r.info.example.documents
        
        // addset(any, dg, d, d.path)
        if (r.info.example.documents.length > 0) {
            dg = inf.add('d-group', kexample)
            ;
            t = dg.add('type', kfolder)
            ;
        }
    }
    IttfFsNode.prototype.toIttf = function(ittfDocumentGraph) {
        // loog 'toIttf, type, this.analized, this.basename, isObject(this.ittfDocumentGraph): ', ittfDocumentGraph.__type, this.analized, this.basename, verify.isObject(this.ittfDocumentGraph)
        var r = this.root();
        if (r === this) {
            this.toIttfRoot(ittfDocumentGraph);
        }
        var n = ittfDocumentGraph.add(this.isDirectory ? 'f' : 'd', this.basename);
        n.add('id', this.id)
        if (this.isDirectory) {
            if (this.isPackageRoot || this.root() === this.parent) {
                n.add('is-package-root')
            }
            if (this.isJobFolder) {
                n.add('is-job-folder')
            }
            if (this.isTFolder) {
                n.add('is-t-folder')
            }
            if (this.isInsideTFolder) {
                n.add('is-inside-t-folder')
            }
        }
        else {
            if (this.isFragment) {
                n.add('is-fragment')
            }
            if (this.isExternal) {
                n.add('is-external')
            }
            var usedFragments = this.ittfDocumentGraph.fragments;
            var ittfReferences = this.ittfDocumentGraph.ittfReferences;
            var pretty = mTreeHtmlPrettifier(this.ittfDocumentGraph);
            if (pretty.__is_error) {
                n.add('ittf', 'Error: not loaded')
            }
            else {
                var ittfSource = n.add('ittf', verify.makeInline(pretty.prettyLines.join('')));
                var r = this.root();
                var ittfBasePath = r.ittfBasePath;
                var i, i_items=Object.keys(usedFragments), i_len=Object.keys(usedFragments).length, item;
                for (i=0; i<i_len; i++) {
                    item = Object.keys(usedFragments)[i];
                    // loog 'usedFragments[k]', item, usedFragments[item]
                    var ittfFragmentsNode = ittfSource.add('fragment', item);
                    ittfFragmentsNode.add('d-id', usedFragments[item].id)
                    ittfFragmentsNode.add('rel-uri', unixifyPath(path.relative(ittfBasePath, usedFragments[item].uri)))
                }
                var i, i_items=Object.keys(ittfReferences), i_len=Object.keys(ittfReferences).length, item;
                for (i=0; i<i_len; i++) {
                    item = Object.keys(ittfReferences)[i];
                    var ittfFragmentsNode = ittfSource.add('reference', item);
                    ittfFragmentsNode.add('d-id', ittfReferences[item].id)
                    ittfFragmentsNode.add('rel-uri', unixifyPath(path.relative(ittfBasePath, ittfReferences[item].uri)))
                }
            }
        }
        if (this.isTest) {
            n.add('is-test')
        }
        if (this.isExample) {
            n.add('is-example')
        }
        if (this.isUtil) {
            n.add('is-util')
        }
        n.add('rel-dirname', this.dirname)
        n.add('rel-uri', this.relPath)
        if (this.isDirectory) {
            var i, i_items=this.folders, i_len=this.folders.length, f;
            for (i=0; i<i_len; i++) {
                f = this.folders[i];
                f.toIttf(n);
            }
            var i, i_items=this.documents, i_len=this.documents.length, d;
            for (i=0; i<i_len; i++) {
                d = this.documents[i];
                if (r === this && d.isExternal) {
                    d.toIttf(ittfDocumentGraph);
                }
                else {
                    d.toIttf(n);
                }
            }
        }
        else {
            n.add('schema', this.schema)
        }
    }
    return IttfFsNode;
})();

function detectSchema(name) {
    var ss = name.split('.');
    if (ss.length > 1) {
        return ss[ss.length -2];
    }
    else {
        return null;
    }
}
function isTFragment(segments) {
    return segments.indexOf('t') > -1;
}
var win32 = process.platform === 'win32';
function unixifyPath(path_string) {
    if (win32) {
        return path_string.replace(/\\/g, '/');
    }
    else {
        return path_string;
    }
}
module.exports = IttfFsNode;
/**
  params
    string code
      # the error name or number
    string method
    string message
      # optional
    { innerError
      # optional
*/
function error(code, method, message, innerError) {
    var parameter = null;
    if (verify.isObject(message)) {
        parameter = message.parameter;
        message = message.message;
    }
    return verify.error(innerError, {
        name: ( verify.isNumber(code) ? 'Err-' + code : code ),
        method: '.' + method,
        parameter: parameter,
        sourcePath: __filename
    }, message || 'Error message unavailable');
}