/*
    artifact generator: C:\Users\stfnb\AppData\Roaming\npm\node_modules\@wizzi\cli\node_modules\@wizzi\plugin.js\lib\artifacts\js\module\gen\main.js
    package: @wizzi/plugin.js@0.8.9
    primary source IttfDocument: C:\My\wizzi\stfnbssl\wizzi\packages\wizzi\.wizzi\lib\services\inmemoryMetaPlugin.js.ittf
    utc time: Tue, 21 Jan 2025 14:15:35 GMT
*/
// generated by wizzi.plugin.js.artifacts.js.module.gen.main
function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };


var stringify = require('json-stringify-safe');
var path = require('path');
var async = require('async');
var packi = require('@wizzi/utils').packi;
var JsonComponents = require('@wizzi/repo').JsonComponents;
var errors = require('./errors');

var FactoryMeta = (function () {
    function FactoryMeta(options) {
        _classCallCheck(this, FactoryMeta);
        this.name = options.name;
        this.version = "0.8.46";
        this.provides = {
            categories: options.pluginCategories, 
            metaProductions: options.pluginMetaProductions
         };
        this.pluginCategories = options.pluginCategories;
        this.pluginMetaProductions = options.pluginMetaProductions;
        this.metaContextDefs = {};
        this.metaProductions = {};
    }
    FactoryMeta.prototype.initialize = function(options, callback) {
        const that = this;
        JsonComponents.packiFilesToUtilVFileJson(options.metaPackiFiles, function(err, jsonFile) {
            if (err) {
                return callback(err);
            }
            that.jsonFile = jsonFile;
            return callback(null);
        })
    }
    FactoryMeta.prototype.getName = function() {
        return this.name;
    }
    FactoryMeta.prototype.getFilename = function() {
        return __filename;
    }
    FactoryMeta.prototype.getProvides = function() {
        return this.provides;
    }
    /**
         Returns the categories of all the productions of the plugin
    */
    FactoryMeta.prototype.getMetaCategoryStarter = function(options, callback) {
        
        return callback(null, this.pluginCategories);
    }
    /**
         Build, if not existent, and retrieve a WizziMetaProduction by its production name.
            Returns
                { metaProduction
                 string productionName
                 string metaNamespace
                 { folderTemplates
                 { ittfDocumentTemplates
                 { plainDocuments
                 { metaCtxSchema
                 { wzCtxSchema
    */
    FactoryMeta.prototype.getMetaProduction = function(productionName, callback) {
        
        var metaProduction = this.metaProductions[productionName] || null;
        
        if (metaProduction != null) {
            return callback(null, metaProduction);
        }
        
        metaProduction = {};
        return this.getFolderTemplates(productionName, metaProduction, (err, notUsed) => {
                if (err) {
                    console.log("[31m%s[0m", err);
                    return callback(err);
                }
                metaProduction.productionName = productionName;
                metaProduction.metaNamespace = "";
                this.metaProductions[productionName] = metaProduction;
                return callback(null, metaProduction);
            }
            );
    }
    /**
         If the ittf/<productionName>/folderTemplates folder exists
         enrich the metaProduction object with the folderTemplates property
         that contains a packiFile object with the content of the ittf/<productionName>/folderTemplates folder.
         Returns a chained call to the getIttfDocumentTemplates method.
    */
    FactoryMeta.prototype.getFolderTemplates = function(productionName, metaProduction, callback) {
        var folderPath = packi.filePrefix + productionName + '/folderTemplates';
        this.jsonFile.isDirectory(folderPath, (err, result) => {
            if (err) {
                console.log("[31m%s[0m", err);
                return callback(err);
            }
            // loog 'getFolderTemplates', productionName, folderPath, result
            if (result) {
                this.createPackifilesFromFs(folderPath, (err, result) => {
                    if (err) {
                        console.log("[31m%s[0m", err);
                        return callback(err);
                    }
                    metaProduction.folderTemplates = result;
                    return this.getIttfDocumentTemplates(productionName, metaProduction, callback);
                }
                )
            }
            else {
                return this.getIttfDocumentTemplates(productionName, metaProduction, callback);
            }
        }
        )
    }
    /**
         If the ittf/<productionName>/ittfDocumentTemplates folder exists
         enrich the metaProduction object with the ittfDocumentTemplates property
         that contains a packiFile object with the content of the ittf/<productionName>/ittfDocumentTemplates folder.
         Returns a chained call to the getPlainDocuments method.
    */
    FactoryMeta.prototype.getIttfDocumentTemplates = function(productionName, metaProduction, callback) {
        var folderPath = packi.filePrefix + productionName + '/ittfDocumentTemplates';
        this.jsonFile.isDirectory(folderPath, (err, result) => {
            if (err) {
                console.log("[31m%s[0m", err);
                return callback(err);
            }
            // loog 'getIttfDocumentTemplates', productionName, folderPath, result
            if (result) {
                this.createPackifilesFromFs(folderPath, (err, result) => {
                    if (err) {
                        console.log("[31m%s[0m", err);
                        return callback(err);
                    }
                    metaProduction.ittfDocumentTemplates = result;
                    return this.getPlainDocuments(productionName, metaProduction, callback);
                }
                )
            }
            else {
                return this.getPlainDocuments(productionName, metaProduction, callback);
            }
        }
        )
    }
    /**
         If the ittf/<productionName>/plainDocuments folder exists
         enrich the metaProduction object with the plainDocuments property
         that contains a packiFile object with the content of the ittf/<productionName>/plainDocuments folder.
         Returns a chained call to the getMetaCtxSchema method.
    */
    FactoryMeta.prototype.getPlainDocuments = function(productionName, metaProduction, callback) {
        var folderPath = packi.filePrefix + productionName + '/plainDocuments';
        this.jsonFile.isDirectory(folderPath, (err, result) => {
            if (err) {
                console.log("[31m%s[0m", err);
                return callback(err);
            }
            // loog 'getPlainDocuments', productionName, folderPath, result
            if (result) {
                this.createPackifilesFromFs(folderPath, (err, result) => {
                    if (err) {
                        console.log("[31m%s[0m", err);
                        return callback(err);
                    }
                    metaProduction.plainDocuments = result;
                    return callback(null);
                }
                )
            }
            else {
                return callback(null);
            }
        }
        )
    }
    /**
         Build and returns a packiFiles object with all the meta ittf documents
         of the WizziMetaProductions that have the property use<metaProduction>
         of the object options.metaCtx set to true.
         The packiFiles filepaths are built this way:
         - folderTemplates/<ProductionName><metaFilePath>
         - ittfDocumentTemplates/<ProductionName><metaFilePath>
         - plainDocuments/<ProductionName><metaFilePath>
         For each metaProduction used the returned packiFiles object must contain a document
         with filePath 'folderTemplates/<ProductionName>/index.ittf.ittf'
    */
    FactoryMeta.prototype.getMetaProductionStarter = function(options, callback) {
        
        async.map(this.pluginMetaProductions, (prod, callback) => {
            const prodName = prod.name;
            
            // loog 'getMetaProductionStarter.useProduction', useProductionVar, options.metaCtx[useProductionVar]
            if (options && options.metaCtx) {
                const useProductionVar = 'use' + prod.name[0].toUpperCase() + prod.name.substring(1);
                if (!options.metaCtx[useProductionVar]) {
                    return callback(null, {});
                }
            }
            this.getMetaProduction(prodName, (err, metaProduction) => {
                if (err) {
                    console.log("[31m%s[0m", err);
                    return callback(err);
                }
                return callback(null, metaProduction);
            }
            )
        }
        , (err, metaProductions) => {
            const result = {};
            var i, i_items=metaProductions, i_len=metaProductions.length, mp;
            for (i=0; i<i_len; i++) {
                mp = metaProductions[i];
                if (mp.folderTemplates) {
                    for (var k in mp.folderTemplates) {
                        var newk = 'folderTemplates/' + mp.productionName + '/' + k;
                        result[newk] = mp.folderTemplates[k];
                    }
                }
                if (mp.ittfDocumentTemplates) {
                    for (var k in mp.ittfDocumentTemplates) {
                        var newk = 'ittfDocumentTemplates/' + mp.productionName + '/' + k;
                        result[newk] = mp.ittfDocumentTemplates[k];
                    }
                }
            }
            if (mp.plainDocuments) {
                for (var k in mp.plainDocuments) {
                    var newk = 'plainDocuments/' + mp.productionName + '/' + k;
                    result[newk] = mp.plainDocuments[k];
                }
            }
            return callback(null, result);
        }
        )
    }
    /**
         Build, if not existent, and retrieve the contexts of a WizziMetaProduction by its production name.
            Returns
                { metaContextDefs
                 string productionName
                 { metaCtxSchema
                 { wzCtxSchema
    */
    FactoryMeta.prototype.getMetaContextDefs = function(productionName, callback) {
        
        var metaContextDefs = this.metaContextDefs[productionName] || null;
        
        if (metaContextDefs != null) {
            return callback(null, metaContextDefs);
        }
        
        metaContextDefs = {};
        return this.getTParams(productionName, metaContextDefs, (err, notUsed) => {
                if (err) {
                    console.log("[31m%s[0m", err);
                    return callback(err);
                }
                metaContextDefs.productionName = productionName;
                this.metaContextDefs[productionName] = metaContextDefs;
                return callback(null, metaContextDefs);
            }
            );
    }
    /**
         Enrich the metaContextDefs object with the ittf/t/params folder
         that contains the templates for declaring context parameters of meta productions.
         Returns a chained call to the getMetaCtxSchema method.
    */
    FactoryMeta.prototype.getTParams = function(productionName, metaContextDefs, callback) {
        var folderPath = packi.filePrefix + 't/params';
        this.jsonFile.isDirectory(folderPath, (err, result) => {
            if (err) {
                console.log("[31m%s[0m", err);
                return callback(err);
            }
            // loog 'getTParams', productionName, folderPath, result
            if (result) {
                this.createPackifilesFromFs(folderPath, (err, result) => {
                    if (err) {
                        console.log("[31m%s[0m", err);
                        return callback(err);
                    }
                    metaContextDefs.ittfTParams = result;
                    return this.getMetaCtxSchema(productionName, metaContextDefs, callback);
                }
                )
            }
            else {
                return this.getMetaCtxSchema(productionName, metaContextDefs, callback);
            }
        }
        )
    }
    /**
         If the ittf/<productionName>/metaCtxSchema folder exists
         Enrich the metaContextDefs object with the metaCtxSchema property
         that contains a packiFile object with the content of the ittf/<productionName>/metaCtxSchema folder.
         Returns a chained call to the getWzCtxSchema method.
    */
    FactoryMeta.prototype.getMetaCtxSchema = function(productionName, metaContextDefs, callback) {
        var folderPath = packi.filePrefix + productionName + '/metaCtxSchemas';
        this.jsonFile.isDirectory(folderPath, (err, result) => {
            if (err) {
                console.log("[31m%s[0m", err);
                return callback(err);
            }
            // loog 'getMetaCtxSchema', productionName, folderPath, result
            if (result) {
                this.createPackifilesFromFs(folderPath, (err, result) => {
                    if (err) {
                        console.log("[31m%s[0m", err);
                        return callback(err);
                    }
                    metaContextDefs.metaCtxSchema = result;
                    return callback(null);
                }
                )
            }
            else {
                return callback(null);
            }
        }
        )
    }
    /**
         Build and returns a packiFiles object with all the meta ittf documents
         of any WizziMetaProduction
         The packiFiles filepaths are built this way:
         - folderTemplates/<ProductionName><metaFilePath>
         - ittfDocumentTemplates/<ProductionName><metaFilePath>
         - plainDocuments/<ProductionName><metaFilePath>
         For each metaProduction the returned packiFiles object must contain:
         . a document with filePath 'folderTemplates/<ProductionName>/index.ittf.ittf'
         . a document with filePath 'folderTemplates/<ProductionName>/index.ittf.ittf'
    */
    FactoryMeta.prototype.getMetaContextDefsStarter = function(options, callback) {
        
        async.map(this.pluginMetaProductions, (prod, callback) => {
            
            // loog 'getMetaContextDefsStarter.useProduction', useProductionVar, options.metaCtx[useProductionVar]
            if (options && options.metaCtx) {
                const useProductionVar = 'use' + prod.name[0].toUpperCase() + prod.name.substring(1);
                if (!options.metaCtx[useProductionVar]) {
                    return callback(null, {});
                }
            }
            this.getMetaContextDefs(prod.name, (err, metaContextDefs) => {
                if (err) {
                    console.log("[31m%s[0m", err);
                    return callback(err);
                }
                return callback(null, metaContextDefs);
            }
            )
        }
        , (err, metaContextDefs) => {
            const result = {};
            var i, i_items=metaContextDefs, i_len=metaContextDefs.length, mp;
            for (i=0; i<i_len; i++) {
                mp = metaContextDefs[i];
                if (mp.ittfTParams) {
                    for (var k in mp.ittfTParams) {
                        var newk = 'metaCtxSchema/' + mp.productionName + '/t/params/' + k;
                        result[newk] = mp.ittfTParams[k];
                    }
                }
                if (mp.metaCtxSchema) {
                    for (var k in mp.metaCtxSchema) {
                        var newk = 'metaCtxSchema/' + mp.productionName + '/' + k;
                        result[newk] = mp.metaCtxSchema[k];
                    }
                }
            }
            return callback(null, result);
        }
        )
    }
    FactoryMeta.prototype.createMetaPlugin = function(options, callback) {
        return callback(null, this);
    }
    FactoryMeta.prototype.createPackifilesFromFs = function(folderPath, callback) {
        this.jsonFile.getFiles(folderPath, {
            deep: true, 
            documentContent: true
         }, (err, files) => {
            if (err) {
                console.log("[31m%s[0m", err);
                return callback(err);
            }
            const packiFiles = {};
            var i, i_items=files, i_len=files.length, file;
            for (i=0; i<i_len; i++) {
                file = files[i];
                packiFiles[file.relPath] = {
                    type: 'CODE', 
                    contents: file.content
                 };
            }
            return callback(null, packiFiles);
        }
        )
    }
    return FactoryMeta;
})();


function error(errorName, method, message, innerError) {
    return new errors.WizziMetaError(message, null, {
            errorName: errorName, 
            method: md.name + '.' + method, 
            sourcePath: __filename, 
            inner: innerError
         });
}

module.exports = {
    version: '0.8.46', 
    createMetaPlugin: function(options, callback) {
        var meta = new FactoryMeta(options);
        meta.initialize(options, (err, notUsed) => {
            if (err) {
                console.log("[31m%s[0m", err);
                return callback(err);
            }
            return callback(null, meta);
        }
        )
    }
 };